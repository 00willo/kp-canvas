#!/usr/bin/python
#
# Copyright (C) 2013    Ian Firns   <firnsy@kororaproject.org>
#                       Chris Smart <csmart@kororaproject.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import cookielib
import getpass
import json
import optparse
import os
import signal
import sys
import urllib
import urllib2
import yum

from urlgrabber.progress import TextMeter

class Template(object):
  def __init__(self, template=''):
    self._name = None
    self._user = None
    self._id = None
    self._description = None

    self._package_list = PackageList()
    self._package_list_remove = PackageList()
    self._repo_list = RepoList()
    self._repo_list_remove = RepoList()

    self._parse_template( template )

  def _parse_template(self, template):
    if isinstance( template, str ):
      parts = template.split(':')

      if len(parts) == 1:
        self._name = parts[0]

      elif len(parts) == 2:
        self._user = parts[0]
        self._name = parts[1]

    if isinstance(template, dict):
      if 'id' in template:
        self._id = template['id']

      if 'name' in template:
        self._name = template['name']

      if 'account' in template:
        self._user = template['account']

      if 'description' in template:
        self._name = template['description']

      if 'r' in template:
        if isinstance(template['r'], list):
          for r in template['r']:
            self._repo_list.add( Repo( repo=r ) )

      if 'p' in template:
        if isinstance(template['p'], list):
          for p in template['p']:
            self._package_list.add( Package( package=p ) )


  def set(self, template):
    self._parse_template(template)

  @property
  def id(self):
    return self._id

  @property
  def name(self):
    return self._name

  @property
  def account(self):
    return self._user

  @property
  def user(self):
    return self._user

  @property
  def description(self):
    return self._description

  def merge(self, template, clean=False):
    if not isinstance( template, Template ):
      TypeError('template is not of template Template')

    if template.name is not None:
      self._name = template.name

    if template.user is not None:
      self._user = template.user

    if template.description is not None:
      self._description = template.description

    pl_install = PackageList()
    pl_remove = PackageList()
    rl_enable = RepoList()

    # look for packages in our template and not in the template being merged
    for op in self._package_list.packages():

      found = False

      for tp in template.getPackageList().packages():
        # match on name only
        if op.name != tp.name:
          continue

        # TODO
        if tp.isPinned():
          pl_install.add( tp )

        found = True

      # a package exists in ours but not in the template being merged
      # remove if we're doing a clean merge
      if not found and clean:
        pl_remove.add( tp )


    # look for package in the merge template and not in our template
    for tp in self._package_list.packages():

      found = False

      for op in template.getPackageList().packages():
        # match on name only
        if op.name != tp.name:
          continue

        # TODO
        if tp.isPinned():
          pl_install.add( tp )

        found = True

      # package is in the merged template but not in our template so let's add
      if not found:
        pl_install.add( tp )


    # look for repos in our template and not in the template being merged
    for tr in template.getRepoList().repos():

      found = False

      for r in self._repo_list.repos():
        # match on name only
        if r.name != tr.name:
          continue

        found = True

      # repo is in the merged template but not in our template so let's add
      if not found:
        rl_enable.add( tr )


    self._package_list = pl_install
    self._package_list_remove = pl_remove
    self._repo_list = rl_enable

  def getPackageList(self):
    return self._package_list

  def getPackageListRemove(self):
    return self._package_list_remove

  def setPackageList(self, package_list):
    if not isinstance(package_list, PackageList):
      TypeError('list is not of type PackageList')

    self._package_list = package_list

  def getRepoList(self):
    return self._repo_list

  def getRepoListRemove(self):
    return self._repo_list_remove

  def setRepoList(self, repo_list):
    if not isinstance(repo_list, RepoList):
      TypeError('list is not of type RepoList')

    self._repo_list = repo_list

  def asObject(self):
    return { 'n': self._name,
             'u': self._user,
             'r': self._repo_list.asObject(),
             'p': self._package_list.asObject() }

  def asJSON(self):
    return json.dumps( self.asObject(), separators=(',',':') )

  def __str__(self):
    return 'Template: %s (owner: %s)' % (self._name, self._user)


class Package(object):
  def __init__(self, name='', epoch='', version='', release='', arch='', pin=False, package=None):
    self._name = str(name)
    self._arch = str(arch)
    self._version = str(version)
    self._epoch = str(epoch)
    self._release = str(release)
    self._pin = pin

    # parse the name if it contains field separators
    if isinstance(name, Package):
      self._parse_package( name )

    elif name.find(':') != -1:
      self._parse_package( name )

    if package is not None:
      self._parse_package( package )

  def _parse_package(self, package):
    if isinstance(package, str):
      parts = package.split(':')

      if len(parts) == 1:
        self._name = parts[0]

      elif len(parts) == 2:
        self._name = parts[0]
        self._version = parts[1]

      elif len(parts) == 3:
        self._name = parts[0]
        self._version = parts[1]
        self._release = parts[2]
        self._arch = parts[3]

    if isinstance(package, dict):
      if 'n' in package:
        self._name = package['n']

      if 'e' in package:
        self._epoch = package['e']

      if 'v' in package:
        self._version = package['v']

      if 'r' in package:
        self._release = package['r']

      if 'a' in package:
        self._arch = package['a']

      if 'p' in package:
        self._pinned = package['p']


  def set(self, package):
    self._parse_package(package)

  @property
  def name(self):
    return self._name

  @property
  def version(self):
    return self._version

  @property
  def release(self):
    return self._release

  def pin(self, state=False):
    self._pin = state

  def isPinned(self):
    return self._pin

  def asObject(self):
    return { 'n': self._name,
             'e': self._epoch,
             'v': self._version,
             'r': self._release,
             'a': self._arch,
             'p': self._pin }

  def asJSON(self):
    return json.dumps( self.asObject(), separators=(',',':') )

  def __str__(self):
    return 'Package: %s (e:%s, v:%s, r:%s, a:%s)' % (self._name, self._epoch, self._version, self._release, self._arch)


class PackageList(object):
  def __init__(self, packages=[]):
    self._packages = []

    self._parse_packages( packages )

  def _parse_packages(self, packages ):
    if isinstance(packages, list):
      for p in packages:
        self._packages.append( Package( p ) )

  def add(self, package):
    if not isinstance( package, Package ):

      raise TypeError('Not a Package object')

    self._packages.append( package )

  def packages(self):
    return self._packages

  def asObject(self):
    return [p.asObject() for p in self._packages]

  def asJSON(self):
    return json.dumps( self.asObject(), separators=(',',':') )

  def count(self):
    return len(self._packages)

  def __str__(self):
    return 'PackageList: %d package.' % ( len(self._packages) )


class Repo(object):
  def __init__(self, id='', name='', baseurl='', mirrorlist='', enabled=False, gpgcheck=False, gpgkey='', meta_expired='', cost=0, exclude=[], repo=None):
    self._id = id
    self._name = name
    self._baseurl = baseurl
    self._mirrorlist = mirrorlist
    self._enabled = enabled
    self._gpgcheck = gpgcheck
    self._gpgkey = gpgkey
    self._meta_expired = meta_expired
    self._cost = cost
    self._exclude = exclude

    if repo is not None:
      self._parse_repo( repo )

  def _parse_repo(self, repo):
    if isinstance(repo, dict):
      if 'id' in repo:
        self._id = repo['id']

      if 'n' in repo:
        self._name = repo['n']

      if 'bu' in repo:
        self._baseurl = repo['bu']

      if 'ml' in repo:
        self._mirrorlist = repo['ml']

      if 'e' in repo:
        self._enabled = repo['e']

      if 'gc' in repo:
        self._gpgcheck = repo['gc']

      if 'gk' in repo:
        self._gpgkey = repo['gk']

      if 'me' in repo:
        self._meta_expired = repo['me']

      if 'c' in repo:
        self._cost = repo['c']

      if 'x' in repo:
        self._expired = repo['x']


  @property
  def name(self):
    return self._name

  def asObject(self):
    return { 'id': self._id,
             'n':  self._name,
             'bu': self._baseurl,
             'ml': self._mirrorlist,
             'e':  self._enabled,
             'gc': self._gpgcheck,
             'gk': self._gpgkey,
             'me': self._meta_expired,
             'c':  self._cost,
             'x':  self._exclude }

  def __str__(self):
    return 'Repo: %s (base: %s, mirror: %s)' % (self._name, self._baseurl, self._mirrorlist)

class RepoList(object):
  def __init__(self, repos=[]):
    self._repos = []

    self._parse_repos( repos )

  def _parse_repos(self, repos ):
    for r in repos:
      if isinstance(r, yum.yumRepo.YumRepository):
        self._repos.append( Repo( r.id, r.name, r.baseurl, r.mirrorlist, r.enabled, r.gpgcheck, r.gpgkey, r.metadata_expire, r.cost, r.exclude ) )

  def add(self, repo):
    if not isinstance( repo, Repo ):
      raise TypeError('Not a Repo object')

    self._repos.append( repo )

  def repos(self):
    return self._repos

  def asObject(self):
    return [r.asObject() for r in self._repos]

  def asJSON(self):
    return json.dumps( self.asObject(), separators=(',',':') )


class CanvasService(object):
  def __init__(self, host='https://canvas.kororaproject.org'):
    self._host = host
    self._urlbase = host

    self._cookiejar = cookielib.CookieJar()
    self._opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self._cookiejar))

    self._authenticated = False

  def authenticate(self, username='', password='', force=False):

    print('Authenticating to %s' % ( self._urlbase ))

    if self._authenticated and not self._force:
      return self._authenticated

    auth = json.dumps( { 'u': username, 'p': password }, separators=(',',':') )

    self._authenticated = False

    try:
      r = urllib2.Request(self._urlbase + '/authenticate.json', auth)
      u = self._opener.open(r)
      self._authenticated = True

    except urllib2.URLError, e:
      print e
    except urllib2.HTTPError, e:
      print e

    return self._authenticated

  def deauthenticate(self, username='', password='', force=False):
    if not self._authenticated and not self._force:
      return self._authenticated

    try:
      r = urllib2.Request('%s/deauthenticate.json' % ( self._urlbase ))
      u = self._opener.open(r)

    except urllib2.URLError, e:
      print e
    except urllib2.HTTPError, e:
      print e

    #
    self._authenticated = False

    return self._authenticated


  def template_create(self, template):

    if not isinstance(template, Template):
      TypeError('template is not of type Template')

    try:
      r = urllib2.Request('%s/api/templates.json' % ( self._urlbase ), template.asJSON())
      u = self._opener.open(r)
      print u.read()

      return True

    except urllib2.URLError, e:
      print e
    except urllib2.HTTPError, e:
      print e

    return False


  def template_delete(self, template_id):

    try:
      r = urllib2.Request('%s/api/template/%d.json' % ( self._urlbase, template_id ))
      r.get_method = lambda: 'DELETE'
      u = self._opener.open(r)
      o = json.loads( u.read() )

      return True

    except urllib2.URLError, e:
      print e
    except urllib2.HTTPError, e:
      print e

    return False


  def template_add(self, template):

    if not isinstance(template, Template):
      TypeError('template is not of type Template')

    try:
      r = urllib2.Request('%s/api/templates.json' % ( self._urlbase ), template.asJSON())
      r.get_method = lambda: 'PUT'
      u = self._opener.open(r)
      print u.read()

      return True

    except urllib2.URLError, e:
      print e
    except urllib2.HTTPError, e:
      print e

    return False


  def template_get(self, template):

    if not isinstance(template, Template):
      TypeError('template is not of type Template')

    query = { 'account': template.user, 'name': template.name }
    try:
      r = urllib2.Request('%s/api/templates.json?%s' % ( self._urlbase, urllib.urlencode(query) ))
      u = self._opener.open(r)

      template_summary = json.loads( u.read() )

      if len( template_summary ):
        # we only have one returned since template names are unique per account
        r = urllib2.Request('%s/api/template/%d.json' % ( self._urlbase, template_summary[0]['id'] ))
        u = self._opener.open(r)

        return Template( template=json.loads( u.read() ) )

    except urllib2.URLError, e:
      print e
    except urllib2.HTTPError, e:
      print e

    return None

  def template_list(self):
    """ Check if the korora template exists
    """
    try:
      r = urllib2.Request('%s/api/templates.json' % ( self._urlbase ))
      u = self._opener.open(r)

      return json.loads( u.read() )

    except urllib2.URLError, e:
      print e
    except urllib2.HTTPError, e:
      print e

    return []

  def template_remove(self, template):

    if not isinstance(template, Template):
      TypeError('template is not of type Template')


class CanvasFormatter(argparse.HelpFormatter):
  def _format_action_invocation(self, action):
    if not action.option_strings:
      default = self._get_default_metavar_for_positional(action)
      metavar, = self._metavar_formatter(action, default)(1)
      return metavar

    parts = []

    # if the Optional doesn't take a value, format is:
    #    -s, --long
    if action.nargs == 0:
      parts.extend(action.option_strings)

    # if the Optional takes a value, format is:
    #    -s ARGS, --long ARGS
    else:
      default = self._get_default_metavar_for_optional(action)
      args_string = self._format_args(action, default)

      for option_string in action.option_strings:
        parts.append(option_string)

      return '%s %s' % (', '.join(parts), args_string)

    return ', ' . join(parts)

  def _get_default_metavar_for_optional(self, action):
    return action.dest.upper()

  def _get_default_metavar_for_positional(self, action):
    return action.dest.upper()


def main():
  def signal_handler(signal, frame):
    print
    sys.exit(0)

  # trap ctrl+c, it's polish
  signal.signal(signal.SIGINT, signal_handler)

  parser = argparse.ArgumentParser(prog='canvas-cli', formatter_class=CanvasFormatter)
  subparsers = parser.add_subparsers(dest='command', title='Commands')

  #
  # general arguments
  parser.add_argument('-u', '--user', type=str, dest='username')
  parser.add_argument('-p', '--pass', action='store_true', dest='password')
  parser.add_argument('--host', type=str, dest='host')
  parser.add_argument('-v', '--verbose', action="store_true", dest='verbose')
  parser.add_argument('-V', '--version', action='version', version='1.0')

  #
  # account general arguments
  parser_account = subparsers.add_parser('account')
  subparsers_account = parser_account.add_subparsers(dest='account_command', title='Account Commands')

  #
  # template general arguments
  parser_template = subparsers.add_parser('template', formatter_class=CanvasFormatter)
  subparsers_template = parser_template.add_subparsers(dest='template_command', title='Template Commands')

  parser_template.add_argument('-n', '--dry-run', action="store_true", dest='dryrun')

  # template create arguments
  parser_template_create = subparsers_template.add_parser('create', formatter_class=CanvasFormatter)

  parser_template_create.add_argument('-i', '--inherit', type=str, dest='inherit')
  parser_template_create.add_argument('template', type=str, help='name of template to be created (eg. user:test)')

  # template list arguments
  parser_template_list = subparsers_template.add_parser('list', formatter_class=CanvasFormatter)

  # template add arguments
  parser_template_add = subparsers_template.add_parser('add', formatter_class=CanvasFormatter)
  parser_template_add.add_argument('--create', action='store_true', dest='create')
  parser_template_add.add_argument('-t', '--template', type=str, dest='template', help='Template to add packages to')
  ptag = parser_template_add.add_mutually_exclusive_group(required=True)
  ptag.add_argument('-s', '--system', action='store_true', dest='system')
  ptag.add_argument('-p', '--packages', dest='packages', nargs='+')

  # template pin arguments
  parser_template_pin = subparsers_template.add_parser('pin', formatter_class=CanvasFormatter)
  parser_template_pin.add_argument('-t', '--template', type=str, dest='template')

  # template unpin arguments
  parser_template_unpin = subparsers_template.add_parser('unpin', formatter_class=CanvasFormatter)
  parser_template_unpin.add_argument('-t', '--template', type=str, dest='template')

  # template remove arguments
  parser_template_remove = subparsers_template.add_parser('remove', formatter_class=CanvasFormatter)
  parser_template_remove.add_argument('-t', '--template', type=str, dest='template')

  # template apply arguments
  parser_template_apply = subparsers_template.add_parser('apply', formatter_class=CanvasFormatter)
  parser_template_apply.add_argument('--clean', action='store_true', dest='merge_clean')
  parser_template_apply.add_argument('-t', '--template', type=str, dest='template')

  # template delete arguments
  parser_template_delete = subparsers_template.add_parser('delete', formatter_class=CanvasFormatter)
  parser_template_delete.add_argument('-t', '--template', type=str, dest='template')

  #
  # package general arguments
  parser_package = subparsers.add_parser('package', formatter_class=CanvasFormatter)
  subparsers_package = parser_package.add_subparsers(dest='package_command', title='Package Commands')

  #
  # machine general arguments
  parser_machine = subparsers.add_parser('machine', formatter_class=CanvasFormatter)
  subparsers_machine = parser_machine.add_subparsers(dest='machine_command', title='Machine Commands')

  # machine create arguments
  parser_machine_create = subparsers_machine.add_parser('create', formatter_class=CanvasFormatter)

  # machine push arguments
  parser_machine_push = subparsers_machine.add_parser('push', formatter_class=CanvasFormatter)

  # machine add arguments
  parser_machine_pull = subparsers_machine.add_parser('pull', formatter_class=CanvasFormatter)

  # machine sync arguments
  parser_machine_sync = subparsers_machine.add_parser('sync', formatter_class=CanvasFormatter)

  args = parser.parse_args()



  # prompt for password if requested
  password = ''
  if args.password:
    password = getpass.getpass()

  if args.host:
    cs = CanvasService(host=args.host)
  else:
    cs = CanvasService()


  if args.command == 'template':
    # no template created for list
    if args.template_command != 'list':
      t = Template( args.template )

    if args.template_command == 'create':
      if args.inherit:
        i = Template( args.inherit )
        print 'Inheriting from: ' + str(i)

      if args.dryrun:
        print 'The following template would be created:'
        print '  - %s' % ( str(t) )

      # perform the real action
      else:
        if not cs.authenticate(args.username, password):
          print 'Unable to authenticate with canvas service.'
          sys.exit(1)

        cs.template_create( t )
        cs.deauthenticate()


    if args.template_command == 'delete':
      print 'The following template will be deleted:'
      print '  - %s' % ( str(t) )

      if args.dryrun:
        print 'No action peformed during this dry-run.'

      # perform the real action
      else:
        if not cs.authenticate(args.username, password):
          print 'Unable to authenticate with canvas service.'
          sys.exit(1)

        t_delete = cs.template_get( t )

        if t_delete is not None:
          cs.template_delete( t_delete )
          print 'Template deleted.'

        else:
          print 'Template not found.'

        cs.deauthenticate()


    elif args.template_command == 'list':
        if not cs.authenticate(args.username, password):
          print 'Unable to authenticate with canvas service.'
          sys.exit(1)

        tl = cs.template_list()

        if len( tl ):
          print 'Templates:'

          for t in tl:
            print '  - %s (%s)' % ( t['name'], t['owner'] )

          print
          print '%d template(s) found.' % ( len(tl) )

        else:
          print '0 templates found. \'Tis the dawn of time.'

        cs.deauthenticate()

    elif args.template_command == 'add':
      pl = PackageList( args.packages )

      if args.system:
        print 'Adding current system packages to template ...'

        yb = yum.YumBase()

        pkgs = yb.rpmdb.returnPackages()

        for p in pkgs:
          _yd = p.yumdb_info
          if _yd.get('reason') == 'user':
            pl.add( Package( name=p.name, epoch=p.epoch, version=p.version, release=p.release, arch=p.arch) )


        rl = RepoList( yb.repos.listEnabled() )

        t.setPackageList( pl )
        t.setRepoList( rl )

      if args.dryrun:
        print 'The following would be added to the template %s:' % ( str(t) )

        packages = t.getPackageList().packages()
        packages.sort( key=lambda x: x.name )

        for p in packages:
          print '  - ' + str(p)

        repos = t.getRepoList().repos()
        repos.sort( key=lambda x: x.name )
        for r in repos:
          print '  - ' + str(r)

        print
        print 'Summary:'
        print '  - Packages: %d' % ( len(packages) )
        print '  - Repos: %d' % ( len(repos) )
        print
        print 'No action peformed during this dry-run.'

      # perform the real action
      else:

        if not cs.authenticate(args.username, password):
          print 'Unable to authenticate with canvas service.'
          sys.exit(1)

        t_add = cs.template_get( t )

        if t_add is not None:
          t_add.merge( template=t )
          cs.template_add( t_add )

        elif args.create:
          cs.template_create( t )

        else:
          print 'Template does not exist.'
          sys.exit(1)

        cs.deauthenticate()

    elif args.template_command == 'remove':
      print 'Removing from template: ' + str(t)

      if not args.system and len(args) < 2:
        parser.error('No packages specified.')

      print 'Removing packages from template:'

      l = PackageList( args[2:] )
      print l

      for p in l.packages():
        print "  - " + str(p)

    elif args.template_command == 'apply':
      if not cs.authenticate(args.username, password):
        print 'Unable to authenticate with canvas service.'
        sys.exit(1)

      t_apply = cs.template_get( t )
      cs.deauthenticate()

      # check the template exists
      if t_apply is None:
        print 'Template does not exist.'
        sys.exit(1)

      # calculate existing system specs
      t_system = Template()

      yb = yum.YumBase()
      yb.conf.cache = os.geteuid() != 0

      pkgs = yb.rpmdb.returnPackages()
      pl = PackageList()

      for p in pkgs:
        _yd = p.yumdb_info
        if _yd.get('reason') == 'user':
          pl.add( Package( name=p.name, epoch=p.epoch, version=p.version, release=p.release, arch=p.arch) )

      rl = RepoList( yb.repos.listEnabled() )

      t_system.setPackageList( pl )
      t_system.setRepoList( rl )

      t_apply.merge( template=t_system, clean=args.merge_clean )

      print 'The following actions will be applied to this system:'

      pi = t_apply.getPackageList().packages()
      pi.sort( key=lambda x: x.name )

      for p in pi:
        print '  - Install ' + str(p)

      pr = t_apply.getPackageListRemove().packages()
      pr.sort( key=lambda x: x.name )

      for p in pr:
        print '  - Remove ' + str(p)

      repos = t_apply.getRepoList().repos()
      repos.sort( key=lambda x: x.name )
      for r in repos:
        print '  - Install ' + str(r)

      print
      print 'Summary:'
      print '  - Package(s) installed: %d' % ( len(pi) )
      print '  - Package(s) removed:   %d' % ( len(pr) )
      print '  - Repo(s) added:        %d' % ( len(repos) )
      print

      # show actions on
      if args.dryrun:
        print 'No action peformed during this dry-run.'

      # perform the real action
      else:

        for p in pi:
          if p.isPinned():
            yb.install( ( p.name, p.epoch, p.version, p.release, p.arch) )
          else:
            yb.install( name=p.name )

        for p in pr:
          yb.remove( name=p.name )

        # TODO: yum magic here
        yb.repos.setProgressBar( TextMeter(fo=sys.stdout) )

        yb.repos.doSetup()
        yb.buildTransaction()
        yb.processTransaction()

  elif args.command == 'machine':
    print "Machine"


if __name__ == '__main__':
  main()
